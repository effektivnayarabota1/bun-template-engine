import { walk } from "estree-walker";
import create_module from "../../create_module.js";
import { is_valid } from "../../../utils/names.js";
import check_enable_sourcemap from "../../utils/check_enable_sourcemap.js";
import { print } from "code-red";
import { apply_preprocessor_sourcemap } from "../../../utils/mapped_code.js";
// import { VERSION } from "../../../../shared/version.js";

// TODO to constants
const VERSION = "0.0.0";

function getSourcemapSourceFilename(compile_options) {
  if (!compile_options.filename) return null;
  return compile_options.outputFilename
    ? get_relative_path(
        compile_options.outputFilename,
        compile_options.filename
      )
    : getBasename(compile_options.filename);
}

function getBasename(filename) {
  return filename.split(/[/\\]/).pop();
}

export const generateComponent = ({ componentData, result }) => {
  let output = null;

  if (result) {
    const { compile_options, name } = componentData;
    const banner = `generated by BTE v${VERSION}`;

    const program = { type: "Program", body: result.js };

    walk(program, {
      enter: (node, parent, key) => {
        if (node.type === "Identifier") {
          if (node.name[0] === "@") {
            if (node.name[1] === "_") {
              const alias = componentData.global(node.name.slice(2));
              node.name = alias.name;
            } else {
              let name = node.name.slice(1);

              if (compile_options.hydratable) {
                if (internal_exports.has(`${name}_hydration`)) {
                  name += "_hydration";
                } else if (internal_exports.has(`${name}Hydration`)) {
                  name += "Hydration";
                }
              }

              if (compile_options.dev) {
                if (internal_exports.has(`${name}_dev`)) {
                  name += "_dev";
                } else if (internal_exports.has(`${name}Dev`)) {
                  name += "Dev";
                }
              }

              const alias = componentData.alias(name);
              componentData.helpers.set(name, alias);
              node.name = alias.name;
            }
          } else if (node.name[0] !== "#" && !is_valid(node.name)) {
            // this hack allows x`foo.${bar}` where bar could be invalid

            const literal = { type: "Literal", value: node.name };
            if (parent.type === "Property" && key === "key") {
              parent.key = literal;
            } else if (
              parent.type === "MemberExpression" &&
              key === "property"
            ) {
              parent.property = literal;
              parent.computed = true;
            }
          }
        }
      },
    });

    const referenced_globals = Array.from(
      componentData.globals,
      ([name, alias]) => name !== alias.name && { name, alias }
    ).filter(Boolean);

    if (referenced_globals.length) {
      componentData.helpers.set("globals", componentData.alias("globals"));
    }

    const imported_helpers = Array.from(
      componentData.helpers,
      ([name, alias]) => ({
        name,
        alias,
      })
    );

    create_module(
      program,
      name,
      banner,
      compile_options.sveltePath,
      imported_helpers,
      referenced_globals,
      componentData.imports,
      componentData.vars
        .filter((variable) => variable.module && variable.export_name)
        .map((variable) => ({
          name: variable.name,
          as: variable.export_name,
        })),
      componentData.exports_from
    );

    // program - это просто набор нод
    // в create ssr component этот массив превращается после функции PRINT

    // console.log("* program: ");
    // console.log(program.body[2].declarations[0].init);

    // print собирает строку из тех нод, что в неё помещают!
    // в текущем случает у нас четыре ноды - импорт, объявление css,
    // 	объявление компонента (create_ssr_component) и экспорт компонента

    output = print(program);
  }

  return output.code;
};
